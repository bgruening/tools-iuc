<tool id="episcanpy_cluster_embed" name="Cluster and embed with Episcanpy" version="@tool_version@+galaxy@version_suffix@" profile="@profile@">
    <description>with episcanpy</description>
    <macros>
        <import>macros.xml</import>
    </macros>
    <expand macro="bio_tools"/>
    <expand macro="requirements"/>
    <expand macro="version_command"/>
    <command detect_errors="exit_code"><![CDATA[
@CMD@
      ]]></command>
    <configfiles>
        <configfile name="script_file"><![CDATA[
@CMD_imports@
@CMD_read_inputs@
import episcanpy as esc
#if $method.method == 'pp.lazy'
esc.pp.lazy(
    adata,
    pp_pca=$method.lazy_pp_pca,
    svd_solver='$method.lazy_svd_solver',
    nb_pcs=$method.lazy_nb_pcs,
    n_neighbors=$method.lazy_n_neighbors,
    perplexity=$method.lazy_perplexity,
    method='$method.lazy_method',
    metric='$method.lazy_metric',
    min_dist=$method.lazy_min_dist,
    spread=$method.lazy_spread,
    use_highly_variable=$method.lazy_use_highly_variable,
    n_components=$method.lazy_n_components,
    )

#else if $method.method == 'tl.find_genes'
esc.tl.find_genes(
    adata,
    gtf_file='$method.find_genes_gtf_file',
    key_added='$method.find_genes_key_added',
    upstream=$method.find_genes_upstream,
    feature_type='$method.find_genes_feature_type',
    annotation='$method.find_genes_annotation',
    raw=$method.find_genes_raw)

#else if $method.method == 'tl.get_n_clusters'
esc.tl.getNClusters(
    adata,
    n_cluster=$method.get_n_clusters_n_cluster,
    range_min=$method.get_n_clusters_range_min,
    range_max=$method.get_n_clusters_range_max,
    max_steps=$method.get_n_clusters_max_steps,
    method='$method.get_n_clusters_method',
    #if $method.get_n_clusters_add_key.get_n_clusters_add_key
    key_added=$method.get_n_clusters_add_key.get_n_clusters_add_key.get_n_clusters_key_added
    #else
    key_added=None
    #end if
    )

#else if $method.method == 'tl.kmeans'
esc.tl.kmeans(
    adata,
    num_clusters=$method.kmeans_num_clusters
    )

#else if $method.method == 'tl.hc'
esc.tl.hc(
    adata,
    num_clusters=$method.hc_num_clusters
    )
#end if
adata.write('anndata.h5ad')
]]></configfile>
    </configfiles>
    <inputs>
        <expand macro="inputs_anndata"/>
        <conditional name="method">
            <param argument="method" type="select" label="Method used for Clustering or Embedding">
                <option value="pp.lazy">Embedding: Automatically compute PCA coordinates, loadings and variance decomposition, a neighborhood graph of observations, t-distributed stochastic neighborhood embedding (tSNE) Uniform Manifold Approximation and Projection (UMAP), using 'pp.lazy'</option>
                <option value="tl.find_genes">Embedding: Find genes and add annotations, using 'pp.find_genes'</option>
                <option value="tl.get_n_clusters">Clustering: Test different settings of louvain to obtain the target number of clusters, using 'tl.getNClusters'</option>
                <option value="tl.kmeans">Clustering: Compute kmeans clustering using X_pca fits, using 'tl.kmeans'</option>
                <option value="tl.hc">Clustering: Compute hierarchical clustering using X_pca fits, using 'tl.hc'</option>
            </param>
            <when value="pp.lazy">
                <param name="lazy_pp_pca" value="True" type="select" label="Compute PCA coordinates before the neighborhood graph" help="(pp_pca)">
                    <option value="True" selected="true">True</option>
                    <option value="False">False</option>
                </param>
                <param name="lazy_svd_solver" type="select" label="SVD solver to use" help="(svd_solver)">
                    <option value="arpack" selected="true">arpack (for the ARPACK wrapper in SciPy)</option>
                    <option value="randomized">randomized (for the randomized algorithm due to Halko (2009)</option>
                    <option value="auto">auto (chooses automatically depending on the size of the problem)</option>
                    <option value="lobpcg">lobpcg (an alternative SciPy solver)</option>
                </param>
                <param name="lazy_nb_pcs" value="50" type="integer" label="Number of principal component computed for PCA (and therefore neighbors, tsne and umap)" help="(nb_pcs)"/>
                <param name="lazy_n_neighbors" value="15" type="integer" label="Size of the local neighborhood (number of neighboring data points) used for manifold approximation" help="(n_neighbors)"/>
                <param name="lazy_perplexity" value="30" type="integer" label="Perplexity (number of nearest neighbors used in other manifold learning algorithms)" help="(perplexity)"/>
                <param name="lazy_method" type="select" label="Kernel to use for computing connectivities" help="(method)">
                    <option value="umap" selected="true">umap</option>
                    <option value="gauss">gauss</option>
                </param>
                <param name="lazy_metric" type="select" label="Metric that returns a distance" help="(metric)">
                    <option value="euclidean" selected="true">euclidean</option>
                    <option value="cityblock">cityblock</option>
                    <option value="cosine">cosine</option>
                    <option value="l1">l1</option>
                    <option value="l2">l2</option>
                    <option value="manhattan">manhattan</option>
                    <option value="braycurtis">braycurtis</option>
                    <option value="canberra">canberra</option>
                    <option value="chebyshev">chebyshev</option>
                    <option value="correlation">correlation</option>
                    <option value="dice">dice</option>
                    <option value="hamming">hamming</option>
                    <option value="jaccard">jaccard</option>
                    <option value="kulsinski">kulsinski</option>
                    <option value="mahalanobis">mahalanobis</option>
                    <option value="minkowski">minkowski</option>
                    <option value="rogerstanimoto">rogerstanimoto</option>
                    <option value="russelrao">russelrao</option>
                    <option value="seuclidean">seuclidean</option>
                    <option value="sokalmichener">sokalmichener</option>
                    <option value="sokalsneath">sokalsneath</option>
                    <option value="sqeuclidean">sqeuclidean</option>
                    <option value="yule">yule</option>
                </param>
                <param name="lazy_min_dist" value="0.5" type="float" label="The effective minimum distance between embedded points" help="(min_dist)"/>
                <param name="lazy_spread" value="1.0" type="float" label="The effective scale of embedded points" help="(spread)"/>
                <param name="lazy_use_highly_variable" type="select" label="Use highly variable genes only" help="(use_highly_variable)">
                    <option value="True">True</option>
                    <option value="False" selected="true">False</option>
                </param>
                <param name="lazy_n_components" value="2" type="integer" label="The number of dimensions of the UMAP embedding" help="(n_components)"/>
            </when>
            <when value="tl.find_genes">
                <param name="find_genes_gtf_file" type="data" format="gtf" label="Annotation GTF file" help="(gtf_file)"/>
                <param name="find_genes_key_added" value="transcript_annotation" type="text" label="Key added" help="(key_added)"/>
                <param name="find_genes_upstream" value="2000" type="integer" label="Upstream" help="(upstream)"/>
                <param name="find_genes_feature_type" value="transcript" type="text" label="Feature type" help="(feature_type)"/>
                <param name="find_genes_annotation" value="HAVANA" type="text" label="Annotation" help="(annotation)"/>
                <param name="find_genes_raw" type="select" label="Raw?" help="(raw)">
                    <option value="True">True</option>
                    <option value="False" selected="true">False</option>
                </param>
            </when>
            <when value="tl.get_n_clusters">
                <param name="get_n_clusters_n_cluster" value="14" type="integer" label="Number of clusters" help="(n_cluster)"/>
                <param name="get_n_clusters_method" type="select" label="Clustering method to use" help="(method)">
                    <option value="leiden" selected="true">leiden</option>
                    <option value="louvain">louvain</option>
                </param>
                <param name="get_n_clusters_range_min" value="0" type="integer" label="Range minimum" help="(range_min)"/>
                <param name="get_n_clusters_range_max" value="3" type="integer" label="Range maximum" help="(range_max)"/>
                <param name="get_n_clusters_max_steps" value="20" type="integer" label="Maximum number of steps" help="(max_steps)"/>
                <conditional name="get_n_clusters_add_key">
                    <param argument="get_n_clusters_add_key" type="select" label="Specify the obs variable name?">
                        <option value="True">Yes</option>
                        <option value="False" selected="true">No</option>
                    </param>
                    <when value="True">
                        <param name="get_n_clusters_key_added" value="None" type="text" label="Variable name in obs" help="(key_added)"/>
                    </when>
                    <when value="False"></when>
                </conditional>
            </when>
            <when value="tl.kmeans">
                <param name="kmeans_num_clusters" value="14" type="integer" label="Number of clusters" help="(num_clusters)"/>
            </when>
            <when value="tl.hc">
                <param name="hc_num_clusters" value="14" type="integer" label="Number of clusters" help="(num_clusters)"/>
            </when>
        </conditional>
        <expand macro="inputs_common_advanced"/>
    </inputs>
    <outputs>
        <expand macro="anndata_outputs"/>
    </outputs>
    <tests>
        <test>
            <!-- test 0- pp.lazy -->
            <param name="adata" value="metrics_in_chrX.h5ad" />
            <conditional name="method">
                <param name="method" value="pp_lazy"/>
                <param name="lazy_pp_pca" value="True"/>
                <param name="lazy_svd_solver" value="arpack"/>
                <param name="lazy_nb_pcs" value="50"/>
                <param name="lazy_pp_n_neighbors" value="15"/>
                <param name="lazy_pp_perplexity" value="30"/>
                <param name="lazy_method" value="umap"/>
                <param name="lazy_metric" value="euclidean"/>
                <param name="lazy_min_dist" value="0.5"/>
                <param name="lazy_spread" value="1.0"/>
                <param name="lazy_use_highly_variable" value="False"/>
                <param name="lazy_n_components" value="2"/>
            </conditional>
            <section name="advanced_common">
                <param name="show_log" value="true" />
            </section>
            <output name="anndata_out" file="anndata.h5ad" ftype="h5ad"/>
        </test>
        <test>
            <!-- test 1-tl.find_genes -->
            <param name="adata" value="metrics_in_chrX.h5ad" />
            <conditional name="method">
                <param name="method" value="tl.find_genes"/>
                <param name="find_genes_gtf_file" value="gencode.v19.annotation.gtf"/>
                <param name="find_genes_key_added" value="transcript_annotation"/>
                <param name="find_genes_upstream" value="2000"/>
                <param name="find_genes_feature_type" value="transcript"/>
                <param name="find_genes_annotation" value="HAVANA"/>
                <param name="find_genes_raw" value="False"/>
            </conditional>
            <section name="advanced_common">
                <param name="show_log" value="true" />
            </section>
            <output name="anndata_out" file="anndata.h5ad" ftype="h5ad"/>
        </test>
        <test>
            <!-- test 2-tl.get_n_clusters -->
            <param name="adata" value="metrics_in_chrX.h5ad" />
            <conditional name="method">
                <param name="method" value="tl.get_n_clusters"/>
                <param name="get_n_clusters_n_clusters" value="14"/>
                <param name="get_n_clusters_method" value="leiden"/>
                <param name="get_n_clusters_range_min" value="0"/>
                <param name="get_n_clusters_range_max" value="3"/>
                <param name="get_n_clusters_max_steps" value="20"/>
                <conditional name="get_n_clusters_add_key">
                    <param name="get_n_clusters_key_added" value="None"/>
                </conditional>
            </conditional>
            <section name="advanced_common">
                <param name="show_log" value="true" />
            </section>
            <output name="anndata_out" file="anndata.h5ad" ftype="h5ad"/>
        </test>
        <test>
        <!-- test 3-tl.kmeans -->
            <param name="adata" value="metrics_in_chrX.h5ad" />
            <conditional name="method">
                <param name="method" value="tl.kmeans"/>
                <param name="kmeans_num_clusters" value="14"/>
            </conditional>
            <section name="advanced_common">
                <param name="show_log" value="true" />
            </section>
            <output name="anndata_out" file="anndata.h5ad" ftype="h5ad"/>
        </test>
        <test>
        <!-- test 4-tl.hc -->
            <param name="adata" value="metrics_in_chrX.h5ad" />
            <conditional name="method">
                <param name="method" value="tl.kmeans"/>
                <param name="hc_num_clusters" value="14"/>
            </conditional>
            <section name="advanced_common">
                <param name="show_log" value="true" />
            </section>
            <output name="anndata_out" file="anndata.h5ad" ftype="h5ad"/>
        </test>
    </tests>
    <help><![CDATA[

Automatically compute PCA coordinates (`pp.lazy`)
========================================================================================
This function automatically computes PCA coordinates, loadings and variance decomposition, a neighborhood graph of
observations, t-distributed stochastic neighborhood embedding (tSNE) Uniform Manifold Approximation and Projection (UMAP).

More details on the `episcanpy documentation
<https://colomemaria.github.io/episcanpy_doc/api/episcanpy.api.pp.lazy.html>`__

Find and add gene annotations (`tl.find_genes`)
========================================================================================
This function adds a gene annotation to an AnnData (h5ad) file from annotations file (.annotation.gtf).

More details on the `episcanpy documentation
<https://colomemaria.github.io/episcanpy_doc/api/episcanpy.api.tl.find_genes.html>`__

Automatically obtain target number of clusters (`tl.getNClusters`)
========================================================================================
This function will test different settings of louvain to obtain the target number of clusters.

More details on the `episcanpy documentation
<https://colomemaria.github.io/episcanpy_doc/api/episcanpy.api.tl.getNClusters.html>`__

Perform kmeans clustering (`tl.kmeans`)
========================================================================================
This function will perform kmeans clustering using X_pca fits.

More details on the `episcanpy documentation
<https://colomemaria.github.io/episcanpy_doc/api/episcanpy.api.tl.kmeans.html>`__

Perform kmeans clustering (`tl.hc`)
========================================================================================
This function will perform hierarchical clustering using X_pca fits.

More details on the `episcanpy documentation
<https://colomemaria.github.io/episcanpy_doc/api/episcanpy.api.tl.hc.html>`__


Compute hierarchical clustering using X_pca fits (`tl.hc`)
===================================================================

This function computes heirarchical clustering using X_pca fits using random_state=2019.

More details on the `episcanpy documentation
<https://colomemaria.github.io/episcanpy_doc/api/episcanpy.api.tl.hc.html>`__
    ]]></help>
    <expand macro="citations"/>
</tool>